package main

import (
	"encoding/xml"
	"testing"
)

var testdata []string

func init() {
	testdata = make([]string, len(xml.HTMLEntity))
	idx := 0
	for k := range xml.HTMLEntity {
		testdata[idx] = k
		idx += 1
	}
}

func StringMapReplacement(name string) string {
	if val, ok := xml.HTMLEntity[name]; ok {
		return val
	}
	return ""
}

func StringSwitchReplacement(name string) string {
	// for k,v := range xml.HTMLEntity {
	//     fmt.Printf("case %#v:\n\treturn %#v\n", k, v)
	// }
	switch name {
	case "curren":
		return "¤"
	case "piv":
		return "ϖ"
	case "oelig":
		return "œ"
	case "euro":
		return "€"
	case "iuml":
		return "ï"
	case "hearts":
		return "♥"
	case "chi":
		return "χ"
	case "upsih":
		return "ϒ"
	case "prod":
		return "∏"
	case "rfloor":
		return "⌋"
	case "sup1":
		return "¹"
	case "Ecirc":
		return "Ê"
	case "eth":
		return "ð"
	case "ouml":
		return "ö"
	case "scaron":
		return "š"
	case "Dagger":
		return "‡"
	case "loz":
		return "◊"
	case "dagger":
		return "†"
	case "Beta":
		return "Β"
	case "rarr":
		return "→"
	case "diams":
		return "♦"
	case "agrave":
		return "à"
	case "or":
		return "∨"
	case "circ":
		return "ˆ"
	case "Otilde":
		return "Õ"
	case "clubs":
		return "♣"
	case "mu":
		return "μ"
	case "Atilde":
		return "Ã"
	case "aelig":
		return "æ"
	case "ntilde":
		return "ñ"
	case "gamma":
		return "γ"
	case "OElig":
		return "Œ"
	case "ordm":
		return "º"
	case "Eacute":
		return "É"
	case "Psi":
		return "Ψ"
	case "sigma":
		return "σ"
	case "Oslash":
		return "Ø"
	case "aring":
		return "å"
	case "larr":
		return "←"
	case "AElig":
		return "Æ"
	case "Iota":
		return "Ι"
	case "Prime":
		return "″"
	case "Yacute":
		return "Ý"
	case "Epsilon":
		return "Ε"
	case "Lambda":
		return "Λ"
	case "sigmaf":
		return "ς"
	case "reg":
		return "®"
	case "macr":
		return "¯"
	case "otimes":
		return "⊗"
	case "lang":
		return "〈"
	case "sup":
		return "⊃"
	case "lsquo":
		return "‘"
	case "cedil":
		return "¸"
	case "ccedil":
		return "ç"
	case "ugrave":
		return "ù"
	case "upsilon":
		return "υ"
	case "sect":
		return "§"
	case "Icirc":
		return "Î"
	case "Tau":
		return "Τ"
	case "amp":
		return "&"
	case "sum":
		return "∑"
	case "thinsp":
		return "\u2009"
	case "ETH":
		return "Ð"
	case "divide":
		return "÷"
	case "phi":
		return "φ"
	case "real":
		return "ℜ"
	case "delta":
		return "δ"
	case "eta":
		return "η"
	case "omicron":
		return "ο"
	case "darr":
		return "↓"
	case "forall":
		return "∀"
	case "equiv":
		return "≡"
	case "supe":
		return "⊇"
	case "plusmn":
		return "±"
	case "Aacute":
		return "Á"
	case "acirc":
		return "â"
	case "Theta":
		return "Θ"
	case "eacute":
		return "é"
	case "Rho":
		return "Ρ"
	case "iota":
		return "ι"
	case "oline":
		return "‾"
	case "yuml":
		return "ÿ"
	case "Eta":
		return "Η"
	case "psi":
		return "ψ"
	case "prime":
		return "′"
	case "tau":
		return "τ"
	case "nabla":
		return "∇"
	case "int":
		return "∫"
	case "rsquo":
		return "’"
	case "nsub":
		return "⊄"
	case "rceil":
		return "⌉"
	case "tilde":
		return "˜"
	case "otilde":
		return "õ"
	case "Nu":
		return "Ν"
	case "Pi":
		return "Π"
	case "weierp":
		return "℘"
	case "image":
		return "ℑ"
	case "empty":
		return "∅"
	case "middot":
		return "·"
	case "raquo":
		return "»"
	case "times":
		return "×"
	case "fnof":
		return "ƒ"
	case "Ugrave":
		return "Ù"
	case "ne":
		return "≠"
	case "Chi":
		return "Χ"
	case "sup2":
		return "²"
	case "para":
		return "¶"
	case "ensp":
		return "\u2002"
	case "rsaquo":
		return "›"
	case "uuml":
		return "ü"
	case "Gamma":
		return "Γ"
	case "rArr":
		return "⇒"
	case "emsp":
		return "\u2003"
	case "pound":
		return "£"
	case "minus":
		return "−"
	case "Scaron":
		return "Š"
	case "trade":
		return "™"
	case "uml":
		return "¨"
	case "ocirc":
		return "ô"
	case "ucirc":
		return "û"
	case "Kappa":
		return "Κ"
	case "THORN":
		return "Þ"
	case "lArr":
		return "⇐"
	case "nbsp":
		return "\u00a0"
	case "cong":
		return "≅"
	case "zwnj":
		return "\u200c"
	case "lfloor":
		return "⌊"
	case "permil":
		return "‰"
	case "deg":
		return "°"
	case "Omega":
		return "Ω"
	case "sdot":
		return "⋅"
	case "spades":
		return "♠"
	case "rlm":
		return "\u200f"
	case "Egrave":
		return "È"
	case "uacute":
		return "ú"
	case "le":
		return "≤"
	case "oplus":
		return "⊕"
	case "bull":
		return "•"
	case "cup":
		return "∪"
	case "brvbar":
		return "¦"
	case "Agrave":
		return "À"
	case "yacute":
		return "ý"
	case "Zeta":
		return "Ζ"
	case "Ocirc":
		return "Ô"
	case "oacute":
		return "ó"
	case "rho":
		return "ρ"
	case "infin":
		return "∞"
	case "hellip":
		return "…"
	case "lowast":
		return "∗"
	case "lt":
		return "<"
	case "acute":
		return "´"
	case "Euml":
		return "Ë"
	case "quot":
		return "\""
	case "frac12":
		return "½"
	case "theta":
		return "θ"
	case "exist":
		return "∃"
	case "there4":
		return "∴"
	case "Igrave":
		return "Ì"
	case "Uuml":
		return "Ü"
	case "kappa":
		return "κ"
	case "asymp":
		return "≈"
	case "auml":
		return "ä"
	case "notin":
		return "∉"
	case "ni":
		return "∋"
	case "rdquo":
		return "”"
	case "prop":
		return "∝"
	case "Xi":
		return "Ξ"
	case "frasl":
		return "⁄"
	case "uArr":
		return "⇑"
	case "hArr":
		return "⇔"
	case "Iuml":
		return "Ï"
	case "iacute":
		return "í"
	case "gt":
		return ">"
	case "frac14":
		return "¼"
	case "pi":
		return "π"
	case "ang":
		return "∠"
	case "micro":
		return "µ"
	case "dArr":
		return "⇓"
	case "yen":
		return "¥"
	case "euml":
		return "ë"
	case "zwj":
		return "\u200d"
	case "lceil":
		return "⌈"
	case "lsaquo":
		return "‹"
	case "nu":
		return "ν"
	case "omega":
		return "ω"
	case "thetasym":
		return "ϑ"
	case "isin":
		return "∈"
	case "epsilon":
		return "ε"
	case "ge":
		return "≥"
	case "bdquo":
		return "„"
	case "shy":
		return "\u00ad"
	case "Ntilde":
		return "Ñ"
	case "Ouml":
		return "Ö"
	case "ecirc":
		return "ê"
	case "iexcl":
		return "¡"
	case "Acirc":
		return "Â"
	case "ograve":
		return "ò"
	case "Yuml":
		return "Ÿ"
	case "Phi":
		return "Φ"
	case "sbquo":
		return "‚"
	case "Aring":
		return "Å"
	case "sube":
		return "⊆"
	case "rang":
		return "〉"
	case "not":
		return "¬"
	case "Delta":
		return "Δ"
	case "and":
		return "∧"
	case "Iacute":
		return "Í"
	case "Upsilon":
		return "Υ"
	case "alefsym":
		return "ℵ"
	case "uarr":
		return "↑"
	case "Ograve":
		return "Ò"
	case "aacute":
		return "á"
	case "alpha":
		return "α"
	case "Alpha":
		return "Α"
	case "atilde":
		return "ã"
	case "egrave":
		return "è"
	case "icirc":
		return "î"
	case "thorn":
		return "þ"
	case "laquo":
		return "«"
	case "Ccedil":
		return "Ç"
	case "szlig":
		return "ß"
	case "sub":
		return "⊂"
	case "crarr":
		return "↵"
	case "radic":
		return "√"
	case "sim":
		return "∼"
	case "ndash":
		return "–"
	case "copy":
		return "©"
	case "frac34":
		return "¾"
	case "Oacute":
		return "Ó"
	case "igrave":
		return "ì"
	case "ldquo":
		return "“"
	case "harr":
		return "↔"
	case "cap":
		return "∩"
	case "cent":
		return "¢"
	case "sup3":
		return "³"
	case "Mu":
		return "Μ"
	case "lambda":
		return "λ"
	case "Omicron":
		return "Ο"
	case "zeta":
		return "ζ"
	case "lrm":
		return "\u200e"
	case "iquest":
		return "¿"
	case "oslash":
		return "ø"
	case "Sigma":
		return "Σ"
	case "part":
		return "∂"
	case "perp":
		return "⊥"
	case "Auml":
		return "Ä"
	case "Uacute":
		return "Ú"
	case "Ucirc":
		return "Û"
	case "xi":
		return "ξ"
	case "ordf":
		return "ª"
	case "beta":
		return "β"
	case "mdash":
		return "—"
	default:
		return ""
	}
}

func StringSwitchLengthReplacement(name string) string {
	// m := make(map[int]string)
	// for k,v := range xml.HTMLEntity {
	//     m[len(k)] += fmt.Sprintf("\tcase %#v:\n\t\treturn %#v\n", k, v)
	// }
	// for size, val := range m {
	//     fmt.Printf("case %d:\n%s", size, val)
	// }
	// Do the size once
	switch len(name) {
	case 7:
		switch name {
		case "alefsym":
			return "ℵ"
		case "epsilon":
			return "ε"
		case "Upsilon":
			return "Υ"
		case "Omicron":
			return "Ο"
		case "omicron":
			return "ο"
		case "Epsilon":
			return "Ε"
		case "upsilon":
			return "υ"
		}
	case 8:
		switch name {
		case "thetasym":
			return "ϑ"
		}
	case 6:
		switch name {
		case "Ugrave":
			return "Ù"
		case "egrave":
			return "è"
		case "rfloor":
			return "⌋"
		case "otimes":
			return "⊗"
		case "Eacute":
			return "É"
		case "Otilde":
			return "Õ"
		case "uacute":
			return "ú"
		case "yacute":
			return "ý"
		case "ograve":
			return "ò"
		case "hellip":
			return "…"
		case "thinsp":
			return "\u2009"
		case "plusmn":
			return "±"
		case "Aacute":
			return "Á"
		case "weierp":
			return "℘"
		case "Uacute":
			return "Ú"
		case "curren":
			return "¤"
		case "aacute":
			return "á"
		case "lowast":
			return "∗"
		case "Scaron":
			return "Š"
		case "frac14":
			return "¼"
		case "forall":
			return "∀"
		case "there4":
			return "∴"
		case "Egrave":
			return "È"
		case "Igrave":
			return "Ì"
		case "Ntilde":
			return "Ñ"
		case "rsaquo":
			return "›"
		case "Ograve":
			return "Ò"
		case "Atilde":
			return "Ã"
		case "eacute":
			return "é"
		case "Iacute":
			return "Í"
		case "divide":
			return "÷"
		case "spades":
			return "♠"
		case "Yacute":
			return "Ý"
		case "Oacute":
			return "Ó"
		case "atilde":
			return "ã"
		case "middot":
			return "·"
		case "iquest":
			return "¿"
		case "hearts":
			return "♥"
		case "Agrave":
			return "À"
		case "Dagger":
			return "‡"
		case "permil":
			return "‰"
		case "brvbar":
			return "¦"
		case "iacute":
			return "í"
		case "scaron":
			return "š"
		case "frac12":
			return "½"
		case "Lambda":
			return "Λ"
		case "frac34":
			return "¾"
		case "agrave":
			return "à"
		case "Ccedil":
			return "Ç"
		case "ugrave":
			return "ù"
		case "ntilde":
			return "ñ"
		case "Oslash":
			return "Ø"
		case "lambda":
			return "λ"
		case "lsaquo":
			return "‹"
		case "igrave":
			return "ì"
		case "dagger":
			return "†"
		case "otilde":
			return "õ"
		case "oslash":
			return "ø"
		case "lfloor":
			return "⌊"
		case "ccedil":
			return "ç"
		case "oacute":
			return "ó"
		case "sigmaf":
			return "ς"
		}
	case 5:
		switch name {
		case "kappa":
			return "κ"
		case "radic":
			return "√"
		case "tilde":
			return "˜"
		case "gamma":
			return "γ"
		case "infin":
			return "∞"
		case "Ecirc":
			return "Ê"
		case "Omega":
			return "Ω"
		case "notin":
			return "∉"
		case "lsquo":
			return "‘"
		case "ecirc":
			return "ê"
		case "ndash":
			return "–"
		case "trade":
			return "™"
		case "Icirc":
			return "Î"
		case "Sigma":
			return "Σ"
		case "delta":
			return "δ"
		case "frasl":
			return "⁄"
		case "asymp":
			return "≈"
		case "oline":
			return "‾"
		case "Ucirc":
			return "Û"
		case "lceil":
			return "⌈"
		case "clubs":
			return "♣"
		case "iexcl":
			return "¡"
		case "THORN":
			return "Þ"
		case "empty":
			return "∅"
		case "oplus":
			return "⊕"
		case "rdquo":
			return "”"
		case "AElig":
			return "Æ"
		case "diams":
			return "♦"
		case "acirc":
			return "â"
		case "ucirc":
			return "û"
		case "Gamma":
			return "Γ"
		case "icirc":
			return "î"
		case "cedil":
			return "¸"
		case "aelig":
			return "æ"
		case "image":
			return "ℑ"
		case "laquo":
			return "«"
		case "alpha":
			return "α"
		case "exist":
			return "∃"
		case "equiv":
			return "≡"
		case "pound":
			return "£"
		case "thorn":
			return "þ"
		case "Kappa":
			return "Κ"
		case "acute":
			return "´"
		case "upsih":
			return "ϒ"
		case "OElig":
			return "Œ"
		case "Ocirc":
			return "Ô"
		case "szlig":
			return "ß"
		case "aring":
			return "å"
		case "Prime":
			return "″"
		case "mdash":
			return "—"
		case "Acirc":
			return "Â"
		case "crarr":
			return "↵"
		case "sbquo":
			return "‚"
		case "micro":
			return "µ"
		case "nabla":
			return "∇"
		case "Alpha":
			return "Α"
		case "bdquo":
			return "„"
		case "theta":
			return "θ"
		case "times":
			return "×"
		case "ocirc":
			return "ô"
		case "oelig":
			return "œ"
		case "Theta":
			return "Θ"
		case "Delta":
			return "Δ"
		case "raquo":
			return "»"
		case "omega":
			return "ω"
		case "minus":
			return "−"
		case "Aring":
			return "Å"
		case "prime":
			return "′"
		case "rceil":
			return "⌉"
		case "sigma":
			return "σ"
		case "ldquo":
			return "“"
		case "rsquo":
			return "’"
		}
	case 3:
		switch name {
		case "Phi":
			return "Φ"
		case "shy":
			return "\u00ad"
		case "sub":
			return "⊂"
		case "uml":
			return "¨"
		case "rlm":
			return "\u200f"
		case "and":
			return "∧"
		case "rho":
			return "ρ"
		case "piv":
			return "ϖ"
		case "Eta":
			return "Η"
		case "lrm":
			return "\u200e"
		case "amp":
			return "&"
		case "deg":
			return "°"
		case "sim":
			return "∼"
		case "Chi":
			return "Χ"
		case "int":
			return "∫"
		case "zwj":
			return "\u200d"
		case "cup":
			return "∪"
		case "ETH":
			return "Ð"
		case "not":
			return "¬"
		case "loz":
			return "◊"
		case "phi":
			return "φ"
		case "cap":
			return "∩"
		case "eth":
			return "ð"
		case "sup":
			return "⊃"
		case "tau":
			return "τ"
		case "chi":
			return "χ"
		case "Rho":
			return "Ρ"
		case "Tau":
			return "Τ"
		case "reg":
			return "®"
		case "Psi":
			return "Ψ"
		case "psi":
			return "ψ"
		case "yen":
			return "¥"
		case "ang":
			return "∠"
		case "eta":
			return "η"
		case "sum":
			return "∑"
		}
	case 4:
		switch name {
		case "part":
			return "∂"
		case "circ":
			return "ˆ"
		case "quot":
			return "\""
		case "ordm":
			return "º"
		case "nsub":
			return "⊄"
		case "para":
			return "¶"
		case "uArr":
			return "⇑"
		case "Iota":
			return "Ι"
		case "emsp":
			return "\u2003"
		case "sup2":
			return "²"
		case "copy":
			return "©"
		case "euml":
			return "ë"
		case "Beta":
			return "Β"
		case "ordf":
			return "ª"
		case "Iuml":
			return "Ï"
		case "isin":
			return "∈"
		case "lang":
			return "〈"
		case "sup3":
			return "³"
		case "Yuml":
			return "Ÿ"
		case "ensp":
			return "\u2002"
		case "iota":
			return "ι"
		case "bull":
			return "•"
		case "prop":
			return "∝"
		case "lArr":
			return "⇐"
		case "zeta":
			return "ζ"
		case "macr":
			return "¯"
		case "real":
			return "ℜ"
		case "sdot":
			return "⋅"
		case "Euml":
			return "Ë"
		case "rang":
			return "〉"
		case "fnof":
			return "ƒ"
		case "perp":
			return "⊥"
		case "uuml":
			return "ü"
		case "iuml":
			return "ï"
		case "harr":
			return "↔"
		case "sube":
			return "⊆"
		case "zwnj":
			return "\u200c"
		case "auml":
			return "ä"
		case "darr":
			return "↓"
		case "Zeta":
			return "Ζ"
		case "euro":
			return "€"
		case "cent":
			return "¢"
		case "sect":
			return "§"
		case "yuml":
			return "ÿ"
		case "sup1":
			return "¹"
		case "Ouml":
			return "Ö"
		case "nbsp":
			return "\u00a0"
		case "dArr":
			return "⇓"
		case "prod":
			return "∏"
		case "supe":
			return "⊇"
		case "rarr":
			return "→"
		case "ouml":
			return "ö"
		case "beta":
			return "β"
		case "larr":
			return "←"
		case "uarr":
			return "↑"
		case "rArr":
			return "⇒"
		case "Auml":
			return "Ä"
		case "cong":
			return "≅"
		case "Uuml":
			return "Ü"
		case "hArr":
			return "⇔"
		}
	case 2:
		switch name {
		case "mu":
			return "μ"
		case "le":
			return "≤"
		case "pi":
			return "π"
		case "xi":
			return "ξ"
		case "Mu":
			return "Μ"
		case "ni":
			return "∋"
		case "or":
			return "∨"
		case "ge":
			return "≥"
		case "gt":
			return ">"
		case "ne":
			return "≠"
		case "nu":
			return "ν"
		case "lt":
			return "<"
		case "Nu":
			return "Ν"
		case "Xi":
			return "Ξ"
		case "Pi":
			return "Π"
		}
	}
	return ""
}

func BenchmarkStringLookupLengthSwitch(b *testing.B) {
	for i := 0; i < b.N; i++ {
		for _, name := range testdata {
			StringSwitchLengthReplacement(name)
		}
	}
}

func BenchmarkStringLookupSwitch(b *testing.B) {
	for i := 0; i < b.N; i++ {
		for _, name := range testdata {
			StringSwitchReplacement(name)
		}
	}
}

func BenchmarkStringBenchmarkLookupMap(b *testing.B) {
	for i := 0; i < b.N; i++ {
		for _, name := range testdata {
			StringMapReplacement(name)
		}
	}
}
